Backend ‚Äì Simulaci√≥n de Tr√°fico Concurrente (Hilos y Procesos)
1. Objetivo del proyecto

Este backend implementa una simulaci√≥n de una intersecci√≥n vial de cuatro v√≠as (Norte, Sur, Este, Oeste) controlada por sem√°foros, con llegada de veh√≠culos, control de fases y recopilaci√≥n de estad√≠sticas.

El sistema debe funcionar en dos modos de concurrencia:

Basado en hilos (threading)

Basado en procesos (multiprocessing)

La l√≥gica del tr√°fico debe ser reutilizable, de modo que la √∫nica diferencia entre ambas versiones sea el motor de ejecuci√≥n (engine).

2. Principios de dise√±o
2.1 Separaci√≥n estricta de responsabilidades

Dominio (core/)
Contiene la l√≥gica del tr√°fico.
‚ùå No conoce hilos ni procesos.
‚ùå No importa threading ni multiprocessing.

Infraestructura (runtime/)
Contiene la l√≥gica de concurrencia.
‚úî Decide si se usan hilos o procesos.
‚úî Coordina la ejecuci√≥n concurrente.

Aplicaci√≥n (app/)
Configura y ejecuta la simulaci√≥n.
‚úî Selecciona el engine.
‚úî Ejecuta los ticks.

2.2 Regla de oro

El dominio no debe cambiar cuando se cambia de hilos a procesos.

3. Estructura de carpetas
backend/
  core/
    models/
      vehiculo.py
    traffic/
      semaforo.py
      controlador.py
    common/
      tipos.py
      state.py
      stats.py

  runtime/
    engines/
      base.py
      threading_engine.py
      multiprocessing_engine.py
    comms/
      messages.py

  app/
    config.py
    sim.py

  tests/
    test_controlador.py
    test_semaforo.py

4. Descripci√≥n detallada por m√≥dulo
4.1 CORE ‚Äì Dominio del sistema
core/common/tipos.py

Define tipos compartidos y estables del sistema.

Debe contener:

Enum Via ‚Üí N, S, E, O

Enum Color ‚Üí ROJO, AMARILLO, VERDE

üìå No debe contener l√≥gica, solo definiciones.

core/models/vehiculo.py

Representa un veh√≠culo individual.

Responsabilidades:

Guardar:

tiempo de llegada

inicio de espera

salida

Calcular:

tiempo total de espera

Debe permitir:

Marcar inicio de espera

Marcar salida

Calcular m√©tricas sin depender del engine

core/traffic/semaforo.py

Modelo l√≥gico de un sem√°foro por v√≠a.

Responsabilidades:

Mantener una cola de veh√≠culos

Mantener el estado del sem√°foro

Despachar veh√≠culos cuando est√© en VERDE

Debe:

Aceptar veh√≠culos (enqueue)

Cambiar color (set_color)

En cada tick:

permitir pasar N veh√≠culos si est√° VERDE

no permitir paso si est√° ROJO o AMARILLO

‚ùå No debe manejar hilos ni procesos
‚ùå No debe dormir ni sincronizar

core/traffic/controlador.py

Controlador central de tr√°fico.

Responsabilidades:

Decidir qu√© v√≠as tienen luz verde

Evitar colisiones

Implementar fases seguras

Dise√±o recomendado:

Fase NS (N y S VERDE)

Transici√≥n AMARILLO

Fase EW (E y O VERDE)

Transici√≥n AMARILLO

Debe:

Avanzar por ticks

Contar ciclos completos

Retornar un plan Via ‚Üí Color

core/common/stats.py

Agregador de estad√≠sticas globales.

Responsabilidades:

Contar veh√≠culos que cruzan

Acumular tiempos de espera

Calcular promedios

Debe:

Recibir veh√≠culos que cruzaron por tick

Producir un resumen serializable

core/common/state.py

Representa una foto del estado actual del sistema.

Debe contener:

N√∫mero de ciclo

N√∫mero de tick

Estado de luces

Tama√±o de colas

Estad√≠sticas

Este objeto es:

La √∫nica salida del backend

Consumido por GUI, logs o tests

4.2 RUNTIME ‚Äì Infraestructura concurrente
runtime/engines/base.py

Interfaz com√∫n para los engines.

Define el contrato obligatorio:

start() ‚Üí inicializa recursos

step() ‚Üí ejecuta un tick

get_state() ‚Üí devuelve TrafficState

stop() ‚Üí libera recursos

Todos los engines deben cumplir esta interfaz.

runtime/engines/threading_engine.py

Motor basado en hilos.

Responsabilidades:

Crear sem√°foros y controlador

Crear uno o m√°s hilos

Sincronizar ejecuci√≥n por tick

Debe usar:

Lock, Condition, Event u otros mecanismos

Memoria compartida

Debe garantizar:

Ejecuci√≥n segura

Sincronizaci√≥n correcta

Actualizaci√≥n consistente del estado

runtime/engines/multiprocessing_engine.py

Motor basado en procesos.

Responsabilidades:

Crear procesos independientes

Comunicar estado mediante colas o pipes

Agregar resultados en el proceso principal

Debe usar:

multiprocessing.Queue, Pipe, Event, etc.

Comunicaci√≥n expl√≠cita (no memoria compartida directa)

Debe garantizar:

Coordinaci√≥n correcta

Serializaci√≥n de datos

Cierre limpio de procesos

runtime/comms/messages.py

(Optativo pero recomendado)

Define estructuras de mensajes para multiprocessing.

Ejemplos:

Comandos a procesos:

cambiar color

ejecutar tick

detener proceso

Reportes desde procesos:

veh√≠culos cruzados

tama√±o de cola

m√©tricas parciales

4.3 APP ‚Äì Ejecuci√≥n
app/config.py

Contiene par√°metros de configuraci√≥n:

Duraci√≥n de luces

N√∫mero de ticks

Probabilidad de llegada de veh√≠culos

Capacidad de cruce

Debe permitir modificar la simulaci√≥n sin tocar c√≥digo l√≥gico.

app/sim.py

Punto de entrada del backend.

Responsabilidades:

Leer modo de ejecuci√≥n (threading o multiprocessing)

Inicializar el engine

Ejecutar m√∫ltiples ticks (‚â• 10 ciclos)

Mostrar resultados finales

Debe ser posible ejecutarlo con:

python -m backend.app.sim threading
python -m backend.app.sim multiprocessing

4.4 TESTS
tests/test_controlador.py

Verifica:

Alternancia correcta de fases

Conteo de ciclos

Estados v√°lidos

tests/test_semaforo.py

Verifica:

Despacho correcto en verde

No despacho en rojo

Respeto de capacidad por tick

5. Flujo de ejecuci√≥n (tick)

El controlador decide el plan de luces

El engine aplica el plan

Llegan veh√≠culos

Sem√°foros ejecutan tick

Se actualizan estad√≠sticas

Se construye TrafficState

6. Resultado esperado

Al finalizar la simulaci√≥n:

Se completan al menos 10 ciclos

Se generan estad√≠sticas v√°lidas

Ambas versiones (hilos y procesos) producen resultados coherentes

El dise√±o permite agregar GUI sin modificar el backend

7. Criterios de evaluaci√≥n cumplidos

‚úî Programaci√≥n orientada a objetos

‚úî Concurrencia con hilos

‚úî Concurrencia con procesos

‚úî Sincronizaci√≥n expl√≠cita

‚úî Arquitectura limpia y modular

‚úî C√≥digo mantenible y extensible

8. Nota final

Este backend est√° dise√±ado para:

crecer sin romperse

facilitar el trabajo en equipo

demostrar comprensi√≥n real de concurrencia

Si una clase cambia de motor (hilos ‚Üí procesos) y no hay que tocarla, el dise√±o es correcto.